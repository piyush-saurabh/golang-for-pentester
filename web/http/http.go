package main

import (
	"crypto/tls"
	"fmt"
	"os"
	"strings"

	"github.com/fatih/color"
	"github.com/valyala/fasthttp"
)

// PROXY address of proxy server e.g. burp
const PROXY string = "127.0.0.1:8090"

// HTTPRequest represents HTTP Request
// HTTP Headers are separated by \n
type HTTPRequest struct {
	URL       string
	Method    string
	Headers   string //"Cookie:flash=no\nContent-Type:application/x-www-form-urlencoded"
	Body      []byte // []byte("data")
	withProxy bool
}

// HTTPResponse represents the response returned by the server
type HTTPResponse struct {
	StatusCode int
	Headers    fasthttp.ResponseHeader
	Body       []byte
}

func main() {

	// initialize struct
	request := HTTPRequest{
		URL:       "http://url.com/",
		Method:    "POST",
		Headers:   "Cookie:flash=no\nContent-Type:application/x-www-form-urlencoded",
		Body:      []byte("request-body"),
		withProxy: true,
	}

	response, err := sendHTTPRequest(request)

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	fmt.Println(response)

}

// Helper functions
// Send HTTP Request
func sendHTTPRequest(request HTTPRequest) (HTTPResponse, error) {

	var err error

	req, res := fasthttp.AcquireRequest(), fasthttp.AcquireResponse()
	defer fasthttp.ReleaseRequest(req)
	defer fasthttp.ReleaseResponse(res)

	// Set the User-Agent
	req.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0")

	// Set the HTTP Headers
	if request.Headers != "" {
		headers := strings.Split(request.Headers, "\n")
		for _, header := range headers {

			headerArray := strings.Split(header, ":")
			req.Header.Set(headerArray[0], headerArray[1])
		}
	}

	// Set HTTP Method
	switch request.Method {
	case "GET":
		req.Header.SetMethod(fasthttp.MethodGet)
	case "POST":
		req.Header.SetMethod(fasthttp.MethodPost)
		req.SetBody(request.Body)
	case "PUT":
		req.Header.SetMethod(fasthttp.MethodPut)
		req.SetBody(request.Body)
	case "DELETE":
		req.Header.SetMethod(fasthttp.MethodDelete)
		req.SetBody(request.Body)
	}

	var proxyClient *fasthttp.HostClient
	var normalClient *fasthttp.Client

	// Set URL
	req.SetRequestURI(request.URL)

	if request.withProxy {

		// with proxy
		proxyClient = &fasthttp.HostClient{
			Addr:                     PROXY,
			TLSConfig:                &tls.Config{InsecureSkipVerify: true},
			NoDefaultUserAgentHeader: false,
		}

		err = proxyClient.Do(req, res)
	} else {
		// without proxy
		normalClient = &fasthttp.Client{
			TLSConfig:                &tls.Config{InsecureSkipVerify: true},
			NoDefaultUserAgentHeader: false,
		}
		err = normalClient.Do(req, res)
	}

	if err != nil {
		color.Set(color.FgHiRed)
		fmt.Println("Could not connect to the server ", request.URL)
		fmt.Println(err)
		color.Unset()
	}

	response := HTTPResponse{
		StatusCode: res.StatusCode(),
		Body:       res.Body(),
		Headers:    res.Header,
	}

	return response, err

}

// Returns the value of a supplied HTTP header
func fetchHeader(headerName string, responseHeaders fasthttp.ResponseHeader) string {

	headers := strings.Split(responseHeaders.String(), "\n")
	var headerValue string

	for _, header := range headers {
		if strings.Contains(header, headerName) {
			headerValue = strings.TrimSpace(strings.Split(header, ":")[1])
			break
		}
	}

	return headerValue

}
