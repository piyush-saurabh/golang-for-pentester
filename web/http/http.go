package main

import (
	"crypto/tls"
	"fmt"
	"os"
	"strings"

	"github.com/fatih/color"
	"github.com/valyala/fasthttp"
)

// PROXY address of proxy server e.g. burp
const PROXY string = "127.0.0.1:8090"

// HTTPRequest represents HTTP Request
// HTTP Headers are separated by \n
type HTTPRequest struct {
	URL       string
	Method    string
	Headers   string //"Cookie:flash=no\nContent-Type:application/x-www-form-urlencoded"
	Body      []byte // []byte("data")
	withProxy bool
}

// HTTPResponse represents the response returned by the server
type HTTPResponse struct {
	StatusCode int
	Headers    fasthttp.ResponseHeader
	Body       []byte
}

func main() {

	// initialize struct
	request := HTTPRequest{
		URL:       "http://url.com/",
		Method:    "POST",
		Headers:   "Cookie:sample=value\nContent-Type:application/x-www-form-urlencoded",
		Body:      []byte("request-body"),
		withProxy: true,
	}

	// Uncomment if accepting command line parameters
	/*
		if len(os.Args) < 3 {
			fmt.Println("[-] Usage reverse_shell.go ip port")
			os.Exit(1)
		}

		ip := os.Args[1]
		port, err := strconv.Atoi(os.Args[2])
		if err != nil {
			color.Set(color.FgHiRed)
			fmt.Println("[-] Port should be a numeric value")
			color.Unset()
			os.Exit(1)
		}
	*/

	log("[+] Sending HTTP Request ...")

	response, err := sendHTTPRequest(request)

	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	printResponse(response)

	log("[+] Terminating the script ...")

}

// Helper functions
// Send HTTP Request
func sendHTTPRequest(request HTTPRequest) (HTTPResponse, error) {

	var err error

	req, res := fasthttp.AcquireRequest(), fasthttp.AcquireResponse()
	defer fasthttp.ReleaseRequest(req)
	defer fasthttp.ReleaseResponse(res)

	// Set URL
	req.SetRequestURI(request.URL)

	// Set the User-Agent
	req.Header.Set("User-Agent", "Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0")

	// Set the HTTP Headers
	if request.Headers != "" {
		headers := strings.Split(request.Headers, "\n")
		for _, header := range headers {
			headerArray := strings.Split(header, ":")
			req.Header.Set(headerArray[0], headerArray[1])
		}
	}

	// Set HTTP Method
	switch request.Method {
	case "GET":
		req.Header.SetMethod(fasthttp.MethodGet)
	case "POST":
		req.Header.SetMethod(fasthttp.MethodPost)
		req.SetBody(request.Body)
	case "PUT":
		req.Header.SetMethod(fasthttp.MethodPut)
		req.SetBody(request.Body)
	case "DELETE":
		req.Header.SetMethod(fasthttp.MethodDelete)
		req.SetBody(request.Body)
	}

	var proxyClient *fasthttp.HostClient
	var normalClient *fasthttp.Client

	if request.withProxy {

		// with proxy
		proxyClient = &fasthttp.HostClient{
			Addr:                     PROXY,
			TLSConfig:                &tls.Config{InsecureSkipVerify: true},
			NoDefaultUserAgentHeader: false,
		}

		err = proxyClient.Do(req, res)
	} else {
		// without proxy
		normalClient = &fasthttp.Client{
			TLSConfig:                &tls.Config{InsecureSkipVerify: true},
			NoDefaultUserAgentHeader: false,
		}
		err = normalClient.Do(req, res)
	}

	if err != nil {
		color.Set(color.FgHiRed)
		fmt.Println("Could not connect to the server ", request.URL)
		fmt.Println(err)
		color.Unset()
	}

	response := HTTPResponse{
		StatusCode: res.StatusCode(),
		Body:       res.Body(),
		Headers:    res.Header,
	}

	return response, err

}

// Print the response on the screen
func printResponse(response HTTPResponse) {

	color.Set(color.FgHiBlue)
	defer color.Unset()

	fmt.Printf("\nStatus\n----------\n")
	color.Set(color.FgHiGreen)
	fmt.Println(response.StatusCode)

	color.Set(color.FgHiBlue)
	fmt.Printf("\nBody\n----------\n")
	color.Set(color.FgHiGreen)
	fmt.Println(string(response.Body))

	color.Set(color.FgHiBlue)
	fmt.Printf("\nHeaders\n----------\n")
	color.Set(color.FgHiGreen)
	fmt.Println(response.Headers.String())

	// Uncomment if HTTP Response returns Set-Cookie header
	/*
		headers := strings.Split(response.Headers.String(), "\n")
		cookie := fetchCookies(headers)
		color.Set(color.FgHiBlue)
		fmt.Printf("\nCookie\n----------\n")
		color.Set(color.FgHiGreen)
		fmt.Println(cookie)
	*/

}

// Returns the value of a supplied HTTP header
func fetchHeader(headerName string, responseHeaders fasthttp.ResponseHeader) string {

	headers := strings.Split(responseHeaders.String(), "\n")
	var headerValue string

	for _, header := range headers {
		if strings.Contains(header, headerName) {
			headerValue = strings.TrimSpace(strings.Split(header, ":")[1])
			break
		}
	}

	return headerValue

}

// Extracts the cookie value fron Set-Cookie variable
// Here the consideration is that only 1 cookie is set using Set-Cookie
func fetchCookies(headers []string) map[string]string {

	var cookie = make(map[string]string)

	for _, header := range headers {

		if strings.Contains(header, "Set-Cookie") {
			headerCookieValue := strings.TrimSpace(strings.Split(header, ":")[1])

			cookieName := strings.TrimSpace(strings.Split(headerCookieValue, "=")[0])
			cookieValue := strings.Split(strings.TrimSpace(strings.Split(headerCookieValue, "=")[1]), ";")[0]

			cookie[cookieName] = cookieValue
			break
		}

	}

	return cookie

}

// Prints the log message
func log(message string) {

	color.Set(color.FgHiYellow)
	fmt.Println(message)
	color.Unset()

}
