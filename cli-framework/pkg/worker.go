package pkg

import (
	"fmt"
	"strings"

	"github.com/fatih/color"
	"github.com/valyala/fasthttp"
)

// Worker method performs the actual operation
func Worker(wordlist chan string, results chan ScannerResult, config *CLIConfig, burpRequest *HTTPRequest) {

	// randID := rand.Intn(10000)
	// fmt.Printf("Worker %d created\n", randID)
	for payload := range wordlist {
		// Some blocking operation
		// Actual logic will be here

		// [TO DO] Replace the placeholder with the payload

		// Send HTTP Request
		response := makeHTTPRequest(config, payload, burpRequest)

		//time.Sleep(time.Millisecond)
		//fmt.Printf("[worker] %s\n", word)

		results <- response
	}

}

// Send HTTP Request
func makeHTTPRequest(config *CLIConfig, payload string, burpRequest *HTTPRequest) ScannerResult {

	// Get request and response handle
	req, res := fasthttp.AcquireRequest(), fasthttp.AcquireResponse()

	// Close the connection
	defer fasthttp.ReleaseRequest(req)
	defer fasthttp.ReleaseResponse(res)

	// Client for making HTTP request
	var client *fasthttp.Client

	// Check for proxy setting
	if *config.Proxy == "" {
		// No proxy set. Make direct connection to the server
		//fmt.Println("No proxy set")
		client = &fasthttp.Client{}
	} else {
		// [TO DO] Proxy set. Route the connection via proxy server
		//fmt.Println("Routing connection via: ", *config.Proxy)
		client = &fasthttp.Client{}
	}

	// Set the URL
	req.SetRequestURI(*config.URL)

	// Burp file provided as input
	if burpRequest != nil {

		// Check the method
		switch burpRequest.Method {
		case "GET":
			req.Header.SetMethod(fasthttp.MethodGet)
		case "POST":
			req.Header.SetMethod(fasthttp.MethodPost)
			req.SetBody(burpRequest.Body)
		case "PUT":
			req.Header.SetMethod(fasthttp.MethodPut)
			req.SetBody(burpRequest.Body)
		case "DELETE":
			req.Header.SetMethod(fasthttp.MethodDelete)
			req.SetBody(burpRequest.Body)
		}

		// Add the HTTP Headers in request
		for _, header := range burpRequest.Headers {
			headerName := strings.Split(header, ":")[0]
			headerValue := strings.TrimSpace(strings.Split(header, ":")[1])
			// header[key] = value
			req.Header.Set(headerName, headerValue)
		}

	} else {
		// No burp file provided as input

		// Set the request method as GET
		req.Header.SetMethod(fasthttp.MethodGet)
	}

	// Set the HTTP request header
	req.Header.Set("User-Agent", "roguesecurity")
	//req.Header.Set("Content-Type", "application/json")

	// Make the HTTP request
	err := client.Do(req, res)
	if err != nil {
		color.Set(color.FgHiRed)
		fmt.Println("Unexpected error occured while making the request with payload: ", payload)
		color.Unset()
	}

	responseBodyBytes := res.Body()

	//fmt.Println("Respone body = ", string(responseBodyBytes))

	// Set the Response
	// Send response
	response := ScannerResult{
		HTTPResponseCode:   res.StatusCode(),
		HTTPResponseLength: len(responseBodyBytes),
		HTTPRequestPayload: payload,
		HTTPResponseBody:   responseBodyBytes,
	}

	return response

	// Check if proxy is set

}
