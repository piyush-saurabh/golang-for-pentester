package pkg

import (
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/valyala/fasthttp"
)

// Worker method performs the actual operation
func Worker(wordlist chan string, results chan ScannerResult, config *CLIConfig, request HTTPRequest) {

	// randID := rand.Intn(10000)
	// fmt.Printf("Worker %d created\n", randID)

	// [IMP] Since header is a slice pointer, the value will be mutable
	// across different workers. Create a copy of header slice
	newHeader := copyHeader(request.Headers)
	fmt.Printf("Old Header %v %d\n\nNew Header %v %d\n", request.Headers, len(request.Headers), newHeader, len(newHeader))
	for payload := range wordlist {
		// Some blocking operation
		// Actual logic will be here

		// Send HTTP Request
		request.Headers = copyHeader(newHeader)
		response := makeHTTPRequest(config, payload, request)

		//time.Sleep(time.Millisecond)
		//fmt.Printf("[worker] %s\n", word)

		results <- response
	}

}

// Send HTTP Request
func makeHTTPRequest(config *CLIConfig, payload string, burpRequest HTTPRequest) ScannerResult {

	// Get request and response handle
	req, res := fasthttp.AcquireRequest(), fasthttp.AcquireResponse()

	// Close the connection
	defer fasthttp.ReleaseRequest(req)
	defer fasthttp.ReleaseResponse(res)

	// Client for making HTTP request
	var client *fasthttp.Client

	// HTTP proxy client if --proxy flag is set
	var proxyClient *fasthttp.HostClient

	// Check for proxy setting
	if *config.Proxy == "" {
		// No proxy set. Make direct connection to the server
		//fmt.Println("No proxy set")
		client = &fasthttp.Client{}
	} else {
		// HTTP Proxy
		proxyClient = &fasthttp.HostClient{
			Addr: *config.Proxy,
		}
		//client = &fasthttp.Client{}
	}

	// Inject the payload into the burp request

	if err := injectPayload(&burpRequest, payload); err != nil {
		color.Set(color.FgHiRed)
		fmt.Println(err)
		color.Unset()
		//os.Exit(1)
	}

	// Set the URL
	req.SetRequestURI(burpRequest.URL)

	// Check the method
	switch burpRequest.Method {
	case "GET":
		req.Header.SetMethod(fasthttp.MethodGet)
	case "POST":
		req.Header.SetMethod(fasthttp.MethodPost)
		req.SetBody(burpRequest.Body)
	case "PUT":
		req.Header.SetMethod(fasthttp.MethodPut)
		req.SetBody(burpRequest.Body)
	case "DELETE":
		req.Header.SetMethod(fasthttp.MethodDelete)
		req.SetBody(burpRequest.Body)
	}

	// Add the HTTP Headers in request
	for _, header := range burpRequest.Headers {
		headerName := strings.Split(header, ":")[0]
		headerValue := strings.TrimSpace(strings.Split(header, ":")[1])
		req.Header.Set(headerName, headerValue)
	}

	// Set the HTTP request header
	//req.Header.Set("Content-Type", "application/json")

	// Start of HTTP Request
	start := time.Now()

	// Make the direct HTTP request if no proxy is set
	if *config.Proxy == "" {
		err := client.Do(req, res)
		if err != nil {
			color.Set(color.FgHiRed)
			fmt.Println("[worker.go] Unexpected error occured while making the request with payload: ", payload)
			fmt.Println(err)
			color.Unset()
		}
	} else {
		// Make request via HTTP Proxy
		err := proxyClient.Do(req, res)
		if err != nil {
			color.Set(color.FgHiRed)
			fmt.Println("[worker.go] Unexpected error occured while making the proxy request with payload: ", payload)
			fmt.Println(err)
			color.Unset()
		}
	}

	// End of HTTP Request
	end := time.Now()
	elapsed := end.Sub(start)

	responseBodyBytes := res.Body()

	// Set the Response
	// Send response
	response := ScannerResult{
		HTTPResponseCode:   res.StatusCode(),
		HTTPResponseLength: len(responseBodyBytes),
		HTTPRequestPayload: payload,
		HTTPResponseBody:   responseBodyBytes,
		HTTPResponseTime:   elapsed,
	}

	return response

}

// Inject payload
func injectPayload(burpRequest *HTTPRequest, payload string) error {

	color.Set(color.FgHiYellow)
	defer color.Unset()

	if strings.Contains(burpRequest.Method, fuzzPlaceholder) {
		// Fuzz HTTP Method
		burpRequest.Method = strings.Replace(burpRequest.Method, fuzzPlaceholder, payload, -1)
		return nil
	} else if strings.Contains(burpRequest.Path, fuzzPlaceholder) {
		// Fuzz Path
		burpRequest.Path = strings.Replace(burpRequest.Path, fuzzPlaceholder, payload, -1)
		burpRequest.URL = strings.Replace(burpRequest.URL, fuzzPlaceholder, payload, -1)
		return nil
	} else if strings.Contains(burpRequest.Host, fuzzPlaceholder) {
		// Fuzz Host
		burpRequest.Host = strings.Replace(burpRequest.Host, fuzzPlaceholder, payload, -1)
		return nil
	}

	// Fuzz Body
	body := string(burpRequest.Body)
	if strings.Contains(body, fuzzPlaceholder) {
		burpRequest.Body = []byte(strings.Replace(string(burpRequest.Body), fuzzPlaceholder, payload, -1))
		return nil
	}

	// Fuzz Headers
	for i, header := range burpRequest.Headers {
		if strings.Contains(header, fuzzPlaceholder) {
			burpRequest.Headers[i] = strings.Replace(header, fuzzPlaceholder, payload, -1)
			return nil
		}

	}

	return errors.New("[worker.go] No injection point detected. Please inject a $FUZZ$ in the burp request file")

}
