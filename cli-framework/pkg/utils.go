package pkg

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	"github.com/fatih/color"
)

// Parse the Burp Request
func parseBurpRequest(filename string) (*HTTPRequest, error) {

	var request []string
	var burpRequest HTTPRequest

	file, err := os.Open(filename)
	defer file.Close()

	if err != nil {
		color.Set(color.FgHiRed)
		fmt.Println("[files.go] Error while opening file")
		color.Unset()
		return nil, err
	}

	scanner := bufio.NewScanner(file)
	isHeader := true
	body := ""
	for scanner.Scan() {

		line := scanner.Text()

		if line == "" {
			isHeader = false
		}

		if isHeader {
			request = append(request, line)
		} else {
			line = strings.TrimSpace(line)
			body += strings.TrimSuffix(line, "\n")
			//fmt.Println("Body " + body)
		}

	}

	burpRequest.Body = []byte(body)
	//fmt.Println("POST BODY", string(burpRequest.Body))

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	burpRequest.Method = strings.Split(request[0], " ")[0]
	burpRequest.Path = strings.Split(request[0], " ")[1]
	burpRequest.Host = strings.TrimSpace(strings.Split(request[1], ":")[1])

	request = request[2:]
	for _, line := range request {
		// lineArray := strings.Split(line, ":")
		// key := lineArray[0]
		// value := strings.TrimSpace(lineArray[1])
		// header[key] = value

		burpRequest.Headers = append(burpRequest.Headers, line)

	}
	//fmt.Println(burpRequest.Headers)

	return &burpRequest, nil

}

// CountWords method counts the number of words (lines) in the workdlist
func CountWords(wordlist string) (int, error) {

	file, err := os.Open(wordlist)
	defer file.Close()

	if err != nil {
		color.Set(color.FgHiRed)
		fmt.Println("[files.go] Error while opening file")
		color.Unset()
		return 0, err
	}

	buf := make([]byte, 32*1024)
	count := 0
	lineSeparator := []byte{'\n'}

	for {
		c, err := file.Read(buf)
		count += bytes.Count(buf[:c], lineSeparator)

		switch {
		case err == io.EOF:
			return count, nil
		case err != nil:
			return count, err
		}
	}

}
