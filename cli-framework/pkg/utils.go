package pkg

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"sync"

	"github.com/cheggaaa/pb"
	"github.com/fatih/color"
)

// ShowProgressBar method displays the progress par based on the number of words processed from the wordlist
// counter is the size of the workdlist
func ShowProgressBar(scannerResult chan ScannerResult, counter int, wg *sync.WaitGroup) {

	defer wg.Done()

	progressBar := pb.StartNew(counter)

	var response ScannerResult
	var responseArray []ScannerResult

	for i := 0; i < counter; i++ {
		response = <-scannerResult
		responseArray = append(responseArray, response)
		progressBar.Increment()
	}

	progressBar.Finish()
	showResponse(responseArray)
}

func showResponse(responseArray []ScannerResult) {
	color.Set(color.FgHiBlue)
	fmt.Printf("Code \t Length\t Payload\n")
	fmt.Printf("===========================\n")
	color.Unset()

	for _, response := range responseArray {
		color.Set(color.FgHiGreen)
		fmt.Printf("%d \t %d \t %s\n", response.HTTPResponseCode, response.HTTPResponseLength, response.HTTPRequestPayload)
		color.Unset()
	}
}

// CountWords method counts the number of words (lines) in the workdlist
func CountWords(wordlist string) (int, error) {

	file, err := os.Open(wordlist)
	defer file.Close()

	if err != nil {
		color.Set(color.FgHiRed)
		fmt.Println("[files.go] Error while opening file")
		color.Unset()
		return 0, err
	}

	buf := make([]byte, 32*1024)
	count := 0
	lineSeparator := []byte{'\n'}

	for {
		c, err := file.Read(buf)
		count += bytes.Count(buf[:c], lineSeparator)

		switch {
		case err == io.EOF:
			return count, nil
		case err != nil:
			return count, err
		}
	}

}
