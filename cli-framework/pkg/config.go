package pkg

import (
	"flag"
	"fmt"
	"os"
	"time"

	"github.com/fatih/color"
)

// ChannelBufferSize is the size of buffered channel which is used to allocate work to the worker goroutines
// Prefered size should be equal to or more than the number of workers
const (
	ChannelBufferSize int = 10
)

const (
	fuzzRegexMarker byte = '~'
)

// HTTPRequest is used to map the request coming from burp
type HTTPRequest struct {
	Method  string
	Path    string
	Host    string
	Headers []string
	Body    []byte
}

// ScannerResult struct captures the response from the server
type ScannerResult struct {
	HTTPResponseCode   int
	HTTPResponseLength int
	HTTPRequestPayload string
	HTTPResponseBody   []byte
	HTTPResponseTime   time.Duration
}

// CLIConfig struct defines the configuration for the CLI
type CLIConfig struct {
	URL              *string
	Wordlist         *string
	BurpRequest      *string
	BurpRequestIsTLS *bool
	WordCount        int
	Workers          *int
	Proxy            *string
	Insecure         *bool
	OutputFileName   *string
}

// InitCLI method initializes the CLI and checks for the command line arguments
func InitCLI() (*CLIConfig, *HTTPRequest) {
	fmt.Println("Initializing .....")

	config := CLIConfig{}
	var burpHTTPRequest *HTTPRequest

	config.URL = flag.String("u", "", "Target URL. E.g. http://www.altoromutual.com:8080/login.jsp (Required)")
	config.Wordlist = flag.String("w", "", "Worldlist file (Required)")
	config.BurpRequest = flag.String("req", "", "Burp Request File")
	config.BurpRequestIsTLS = flag.Bool("tls", true, "Validate the server certificate")
	config.Workers = flag.Int("workers", 5, "Number of workers")
	config.Proxy = flag.String("proxy", "", "Proxy server. E.g. http://127.0.0.1:8080")
	config.Insecure = flag.Bool("insecure", true, "Validate the server certificate")
	config.OutputFileName = flag.String("o", "", "File Name.")

	flag.Parse()

	if len(os.Args) < 2 {
		fmt.Println("Usage cli -u <URL> -w <path/to/wordlist> [--req burp.req] [--workers  10] [--proxy http://127.0.0.1:8080] [--insecure false] [-o file.csv]")
		os.Exit(1)
	}

	// Check if the required parameters 'URL' are provided
	if *config.URL == "" {

		// Check if burp request file is also not provided
		if *config.BurpRequest == "" {
			color.Set(color.FgHiRed)
			fmt.Println("Missing URL")
			flag.Usage()
			color.Unset()
			os.Exit(1)
		}
	}

	// If burp request file is provided, then update the URL
	if *config.BurpRequest != "" {

		// specify the type of request: http/https
		var protocol string

		// Parse the burp request file
		var err error
		burpHTTPRequest, err = parseBurpRequest(*config.BurpRequest)
		if err != nil {
			os.Exit(1)
		}

		// Check if the request is over http/https
		if *config.BurpRequestIsTLS {
			protocol = "https://"
		} else {
			protocol = "http://"
		}

		*config.URL = protocol + burpHTTPRequest.Host + burpHTTPRequest.Path
	} else {
		burpHTTPRequest = nil
	}

	// Check if the required parameters are provided
	if *config.Wordlist == "" {
		color.Set(color.FgHiRed)
		fmt.Println("Missing Wordlist")
		flag.Usage()
		color.Unset()
		os.Exit(1)
	}

	// Count the number of words in the file
	config.WordCount, _ = CountWords(*config.Wordlist)
	if config.WordCount == 0 {
		color.Set(color.FgHiRed)
		fmt.Println("[config.go] Cannot read from the wordlist")
		color.Unset()
		os.Exit(1)
	}

	color.Set(color.FgHiYellow)
	fmt.Println("[-] attacking URL: ", *config.URL)
	fmt.Println("[-] using wordlist: ", *config.Wordlist)
	fmt.Println("[-] number of words loaded: ", config.WordCount)
	fmt.Println("[-] using number of workers: ", *config.Workers)

	if *config.Proxy == "" {
		fmt.Println("[-] starting script without any proxy")
	} else {
		fmt.Println("[-] using proxy: ", *config.Proxy)
	}

	if *config.Insecure {
		fmt.Println("[-] skipping certificate verification")
	} else {

		fmt.Println("[-] certificate verification ENABLED")
	}
	color.Unset()

	return &config, burpHTTPRequest

}
