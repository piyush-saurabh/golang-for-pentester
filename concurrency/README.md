# Concurrency

## Main goroutine
```go
func main() {

  // Domain Size, e.g. wordlist size
  var domainSize int

  // Specify the number of worker goroutines
  var size int 

  var wg sync.WaitGroup
  wg.Add(1)

  // Read the result
  go result(resultChannel, &wg)

  // Create a channel for number of worker go routines
  workerChannel := make(chan string, size)

  // Create a channel to get back the result
  resultChannel := make(chan string)

  // Create 'n' workers
  for i := 0; i < size; i++ {
    go worker(workerChannel, resultChannel)
  }

  // Master assignes the task to the worker
  // Master will iterate over the full wordlist
  go master(workerChannel, domainSize)

  wg.Wait()

  close(workerChannel)
  close(resultChannel)

}
```
## Worker goroutine
```go
func worker(workerChannel chan string, resultChannel chan string){
  for i := range workerChannel {
    // Actual logic will be here
    
    resultChannel <- response
  }
}
```

## Master goroutine
```go
func master(inputChannel chan string, domainSize int){
  for i := range domainSize {
		inputChannel <- somevalue
	}
}
```
## Result
```go
func result(resultChannel chan string, wg *sync.WaitGroup){
  defer wg.Done()
  for {
		// Fetch the response
		<- resultChannel
  }
}
```
