package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"runtime"
	"strconv"
	"sync"
	"time"
)

// PostResponse structure to represent the response body
type PostResponse struct {
	UserID int    `json:"userId"`
	ID     int    `json:"id"`
	Title  string `json:"title"`
	Body   string `json:"body"`
}

// ConcurrentCall method loops over 1-100 IDs to make REST API call in a non concurrent way
func ConcurrentCall() {

	fmt.Println("--------------Concurrent--------------")

	runtime.GOMAXPROCS(4)

	url := "https://jsonplaceholder.typicode.com/posts/"
	var requestURL string

	// Add a wait group to prevent the main function to exit before the goroutines
	var wg sync.WaitGroup

	// Check for the time taken for each call
	start := time.Now()

	//Loop from post ID 1 to 100
	for i := 1; i <= 10; i++ {

		wg.Add(1)
		go func(j int) {

			defer wg.Done()

			requestURL = url + strconv.Itoa(j)

			// Send the GET request
			resp, err := http.Get(requestURL)
			if err != nil {
				// Some error occured
				log.Panicln(err)
			}

			defer resp.Body.Close()

			var postResponse PostResponse

			if err := json.NewDecoder(resp.Body).Decode(&postResponse); err != nil {
				log.Fatalln(err)
			}

			fmt.Println(postResponse)
			fmt.Printf("---------------------------------\n")
		}(i)

	}

	// IMP: To acheive concurrency, place Wait() just before the end of the function
	wg.Wait()

	// End of the time
	elapsed := time.Since(start)

	fmt.Printf("Execution time: %s\n", elapsed)

}
