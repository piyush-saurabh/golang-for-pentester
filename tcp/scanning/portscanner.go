package main

import (
	"fmt"
	"net"
	"sort"
	"strconv"
	"sync"
	"time"
)

const (
	target = "scanme.nmap.org"
)

func nonConcurrent(startPort, endPort int) {

	// Start of the scan
	start := time.Now()

	for i := startPort; i <= endPort; i++ {

		scanTarget := target + ":" + strconv.Itoa(i)
		conn, err := net.Dial("tcp", scanTarget)

		if err != nil {
			// Port is closed
			continue
		}

		// Port is open
		conn.Close()
		fmt.Printf("Port %d is Open\n", i)
	}

	// End time
	end := time.Now()
	elapsed := end.Sub(start)

	fmt.Printf("Total Scan Time: %v\n", elapsed)
}

func tooFastConcurrent() {
	start := time.Now()

	// Synchronization
	var wg sync.WaitGroup

	for i := 79; i < 82; i++ {

		// Before goroutine
		wg.Add(1)

		go func(j int) {

			// Inside goroutine
			defer wg.Done()

			address := target + ":" + strconv.Itoa(j)

			conn, err := net.Dial("tcp", address)

			if err != nil {
				// Port is closed
				return
			}

			// Port is open
			conn.Close()
			fmt.Printf("Port %d is Open\n", j)
		}(i)
	}

	// Wait till the goroutine
	wg.Wait()

	end := time.Now()
	elapsed := end.Sub(start)
	fmt.Printf("Total Scan Time: %v\n", elapsed)
}

// Creates pool of worker goroutines
// They perform actual work
// Use channel to "receive work"
func worker(ports, results chan int) {

	for port := range ports {

		scanTarget := target + ":" + strconv.Itoa(port)

		conn, err := net.Dial("tcp", scanTarget)

		if err != nil {
			// Port is closed
			results <- 0
			continue
		}
		conn.Close()
		results <- port

	}
}

func poolConcurrent(startPort, endPort int) {
	start := time.Now()

	// No of ports each worker routine will scan
	size := 20

	ports := make(chan int, size)
	results := make(chan int)

	var openports []int

	// Create multiple worker routines
	// here, no of worker nodes = no of ports they will be scanning
	for i := 0; i < cap(ports); i++ {
		go worker(ports, results)
	}

	// Start assigning tasks to worker routines

	go func() {
		for i := startPort; i <= endPort; i++ {
			ports <- i
		}
	}()

	// Start reading the results
	for i := startPort; i <= endPort; i++ {
		port := <-results

		if port != 0 {
			openports = append(openports, port)
		}
	}

	close(ports)
	close(results)

	// Sort all the ports
	sort.Ints(openports)
	for _, port := range openports {
		fmt.Printf("Port %d is open\n", port)
	}

	end := time.Now()
	elapsed := end.Sub(start)
	fmt.Printf("Total Scan Time: %v\n", elapsed)
}

func main() {

	startPort := 1
	endPort := 100

	//nonConcurrent(startPort, endPort) // takes ~ 5 mins to scan 100 ports
	//tooFastConcurrent()
	poolConcurrent(startPort, endPort) // takes ~16 sec to scan 100 ports

}
